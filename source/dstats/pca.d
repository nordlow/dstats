/**
This module contains a basic implementation of principal component analysis,
based on the NIPALS algorithm.  This is fast when you only need the first
few components (which is usually the case since PCA's main uses are
visualization and dimensionality reduction).  However, convergence slows
drastically after the first few components have been removed and most of
the matrix is just noise.

References:

en.wikipedia.org/wiki/Principal_component_analysis#Computing_principal_components_iteratively

Author:  David Simcha
*/

/*
 * License:
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */
module dstats.pca;

import std.range, dstats.base, dstats.alloc, std.numeric, std.stdio, std.math,
    std.algorithm, std.array, dstats.summary, dstats.random, std.conv,
    std.exception, dstats.regress, std.traits;

/// Result holder
struct PrincipalComponent {
    /// The projection of the data onto the first principal component.
    double[] x;

    /// The vector representing the first principal component loadings.
    double[] rotation;
}

/**
Sets options for principal component analysis.  The default options are
also the values in PrinCompOptions.init.
*/
struct PrinCompOptions {
    ///  Center each column to zero mean.  Default value:  true.
    bool zeroMean = true;

    /**
    Scale each column to unit variance.  Note that, if this option is set to
    true, zeroMean is ignored and the mean of each column is set to zero even
    if zeroMean is false.  Default value:  false.
    */
    bool unitVariance = false;

    /**
    Overwrite input matrix instead of copying.  Ignored if the matrix
    passed in does not have assignable, lvalue elements and centering or
    scaling is enabled.  Default value:  false.
    */
    bool destructive = false;

    /**
    Effectively transpose the matrix.  If enabled, treat each column as a
    data points and each row as a dimension.  If disabled, do the opposite.
    Note that, if this is enabled, each row will be scaled and centered,
    not each column.  Default value:  false.
    */
    bool transpose = false;

    /**
    Relative error at which to stop the optimization procedure.  Default: 1e-4
    */
    double relError = 1.0e-4;

    /**
    Absolute error at which to stop the optimization procedure.  Default:  1e-5
    */
    double absError = 1.0e-5;

    /**
    Maximum iterations for the optimization procedure.  After this many
    iterations, the algorithm gives up and calls teh solution "good enough"
    no matter what.  For exploratory analyses, "good enough" solutions
    can be had fast sometimes by making this value small.  Default:  uint.max
    */
    uint maxIter = uint.max;

    private void doCenterScaleTransposed(R)(R data) {
        foreach(row; data.save) {
            immutable msd = meanStdev(row.save);

            foreach(ref elem; row) {
                // Already checked for whether we're supposed to be normalizing.
                elem -= msd.mean;
                if(unitVariance) elem /= msd.stdev;
            }
        }
    }

    private void doCenterScale(R)(R data) {
        if(!zeroMean && !unitVariance) return;
        if(data.empty) {
            return;
        }

        if(transpose) return doCenterScaleTransposed(data);

        auto alloc = newRegionAllocator();
        immutable rowLen = walkLength(data.front.save);

        auto summs = alloc.uninitializedArray!(MeanSD[])(rowLen);
        summs[] = MeanSD.init;
        foreach(row; data) {
            size_t i = 0;
            foreach(elem; row) {
                enforce(i < rowLen, "Matrix must be rectangular for PCA.");
                summs[i++].put(elem);
            }

            enforce(i == rowLen, "Matrix must be rectangular for PCA.");
        }

        foreach(row; data) {
            size_t i = 0;
            foreach(ref elem; row) {
                elem -= summs[i].mean;
                if(unitVariance) elem /= summs[i].stdev;
                i++;
            }
        }
    }
}


/**
Uses expectation-maximization to compute the first principal component of mat.
Since there are a lot of options, they are controlled by a PrinCompOptions
struct.  (See above.  PrinCompOptions.init contains the default values.)
To have the results returned in a pre-allocated space, pass an explicit value
for buf.
*/
PrincipalComponent firstComponent(Ror)(
    Ror data,
    PrinCompOptions opts = PrinCompOptions.init,
    PrincipalComponent buf = PrincipalComponent.init
) {
    auto alloc = newRegionAllocator();

    PrincipalComponent doNonDestructive() {
        double[][] dataFixed;

        if(opts.transpose) {
            dataFixed = transposeDup(data, alloc);
        } else {
            dataFixed = doubleTempdupMatrix(data, alloc);
        }

        opts.transpose = false;  // We already transposed if necessary.
        opts.doCenterScale(dataFixed);
        return firstComponentImpl(dataFixed, buf, opts);
    }

    static if(!hasLvalueElements!(ElementType!Ror) ||
    !hasAssignableElements!(ElementType!Ror)) {
        if(opts.zeroMean || opts.unitVariance) {
            return doNonDestructive();
        } else {
            return firstComponentImpl(data, buf, opts);
        }
    } else {
        if(!opts.destructive) {
            return doNonDestructive;
        }

        opts.doCenterScale(data);
        return firstComponentImpl(data, buf, opts);
    }
}

private PrincipalComponent firstComponentImpl(Ror)(
    Ror data,
    PrincipalComponent buf,
    PrinCompOptions opts
) {
    auto alloc = newRegionAllocator();

    if(data.empty) return typeof(return).init;
    size_t rowLen = walkLength(data.front.save);
    size_t colLen = walkLength(data.save);

    immutable transposed = opts.transpose;
    if(transposed) swap(rowLen, colLen);

    auto t = alloc.uninitializedArray!(double[])(rowLen);
    auto p = (buf.rotation.length >= rowLen) ?
              buf.rotation[0..rowLen] : new double[rowLen];
    p[] = 1;

    bool isCloseOrNotFinite(const double[] a, const double[] b) {
        foreach(i; 0..a.length) {
            if(!isFinite(a[i]) || !isFinite(b[i])) {
                return true;
            } else if(!isClose(a[i], b[i], opts.relError, opts.absError)) {
                return false;
            }
        }

        return true;
    }

    uint iter;
    for(; iter < opts.maxIter; iter++) {
        t[] = 0;

        if(transposed) {
            auto dps = alloc.uninitializedArray!(double[])(colLen);
            scope(exit) alloc.freeLast();
            dps[] = 0;

            size_t i = 0;
            foreach(row; data.save) {
                scope(exit) i++;

                static if(is(typeof(row) : const(double)[])) {
                    // Take advantage of array ops.
                    dps[] += p[i] * row[];
                } else {
                    size_t j = 0;
                    foreach(elem; row) {
                        scope(exit) j++;
                        dps[j] += p[i] * elem;
                    }
                }
            }

            i = 0;
            foreach(row; data.save) {
                scope(exit) i++;
                t[i] += dotProduct(row, dps);
            }

        } else {
            foreach(row; data.save) {
                immutable dp = dotProduct(p, row);
                static if( is(typeof(row) : const(double)[] )) {
                    // Use array op optimization if possible.
                    t[] += row[] * dp;
                } else {
                    size_t i = 0;
                    foreach(elem; row.save) {
                        t[i++] += elem * dp;
                    }
                }
            }
        }

        immutable tMagnitude = magnitude(t);
        t[] /= tMagnitude;

        if(isCloseOrNotFinite(t, p)) {
            p[] = t[];
            break;
        }

        p[] = t[];
    }

    auto x = (buf.x.length >= colLen) ?
              buf.x[0..colLen] : new double[colLen];
    size_t i = 0;

    if(transposed) {
        x[] = 0;

        size_t rowIndex = 0;
        foreach(row; data) {
            scope(exit) rowIndex++;
            size_t colIndex = 0;

            foreach(elem; row) {
                scope(exit) colIndex++;
                x[colIndex] += p[rowIndex] * elem;
            }
        }

    } else {
        foreach(row; data) {
            x[i++] = dotProduct(p, row);
        }
    }

    return PrincipalComponent(x, p);
}

/// Used for removeComponent().
enum Transposed : bool {

    ///
    yes = true,

    ///
    no = false
}

/**
Remove the principal component specified by the given rotation vector from
data.  data must have assignable elements.  Transposed controls whether
rotation is considered a loading for the transposed matrix or the matrix
as-is.
*/
void removeComponent(Ror, R)(
    Ror data,
    R rotation,
    Transposed transposed = Transposed.no
) {
    double[2] regressBuf;

    immutable rotMagNeg1 = 1.0 / magnitude(rotation.save);

    if(transposed) {
        auto alloc = newRegionAllocator();
        auto dps = alloc.uninitializedArray!(double[])
            (walkLength(data.front.save));
        dps[] = 0;

        auto r2 = rotation.save;
        foreach(row; data.save) {
            scope(exit) r2.popFront();

            size_t j = 0;

            foreach(elem; row) {
                scope(exit) j++;
                dps[j] += r2.front * elem;
            }
        }

        dps[] *= rotMagNeg1;

        r2 = rotation.save;
        foreach(row; data.save) {
            scope(exit) r2.popFront();

            auto rs = row.save;
            for(size_t j = 0; !rs.empty; rs.popFront, j++) {
                rs.front = rs.front - r2.front * dps[j];
            }
        }

    } else {
        foreach(row; data.save) {
            immutable dotProd = dotProduct(rotation, row);
            immutable coeff = dotProd * rotMagNeg1;

            auto rs = row.save;
            auto rots = rotation.save;
            while(!rs.empty && !rots.empty) {
                scope(exit) {
                    rs.popFront();
                    rots.popFront();
                }

                rs.front = rs.front - rots.front * coeff;
            }
        }
    }
}

/**
Computes the first N principal components of the matrix.  More efficient than
calling firstComponent and removeComponent repeatedly because copying and
transposing, if enabled, only happen once.
*/
PrincipalComponent[] firstNComponents(Ror)(
    Ror data,
    uint n,
    PrinCompOptions opts = PrinCompOptions.init,
    PrincipalComponent[] buf = null
) {

    auto alloc = newRegionAllocator();

    PrincipalComponent[] doNonDestructive() {
        double[][] dataFixed;

        if(opts.transpose) {
            dataFixed = transposeDup(data, alloc);
        } else {
            dataFixed = doubleTempdupMatrix(data, alloc);
        }

        opts.transpose = false;  // We already transposed if necessary.
        opts.doCenterScale(dataFixed);
        return firstNComponentsImpl(dataFixed, n, opts, buf);
    }

    static if(!hasLvalueElements!(ElementType!Ror) ||
    !hasAssignableElements!(ElementType!Ror)) {
        return doNonDestructive();
    } else {
        if(!opts.destructive) {
            return doNonDestructive();
        }

        opts.doCenterScale(data);
        return firstNComponentsImpl(data, n, opts, buf);
    }
}

private PrincipalComponent[] firstNComponentsImpl(Ror)(Ror data, uint n,
    PrinCompOptions opts, PrincipalComponent[] buf = null) {

    opts.destructive = true;  // We already copied if necessary.
    opts.unitVariance = false;  // Already did this.

    buf.length = n;
    foreach(comp; 0..n) {
        if(comp != 0) {
            removeComponent(data, buf[comp - 1].rotation,
                cast(Transposed) opts.transpose);
        }

        buf[comp] = firstComponent(data, opts, buf[comp]);
    }

    return buf;
}

private double magnitude(R)(R x) {
    return sqrt(reduce!"a + b * b"(0.0, x));
}

// Convert the matrix to a double[][].
double[] doubleTempdup(R)(R range, RegionAllocator alloc) {
    return alloc.array(map!(to!double)(range));
}

private double[][] doubleTempdupMatrix(R)(R data, RegionAllocator alloc) {
    auto dataFixed = alloc.uninitializedArray!(double[][])
        (data.length);
    foreach(i, ref elem; dataFixed) {
        elem = doubleTempdup(data[i], alloc);
    }

    return dataFixed;
}

private double[][] transposeDup(Ror)(Ror data, RegionAllocator alloc) {
    if(data.empty) return null;

    immutable rowLen = walkLength(data.front.save);
    immutable colLen = walkLength(data.save);
    auto ret = alloc.uninitializedArray!(double[][])(rowLen, colLen);

    size_t i = 0;
    foreach(row; data) {
        scope(exit) i++;
        if(i == colLen) break;

        size_t j = 0;
        foreach(col; row) {
            scope(exit) j++;
            if(j == rowLen) break;
            ret[j][i] = col;
        }

        dstatsEnforce(j == rowLen, "Matrices must be rectangular for PCA.");
    }

    dstatsEnforce(i == colLen, "Matrices must be rectangular for PCA.");
    return ret;
}

version(unittest) {
    // There are two equally valid answers for PCA that differ only by sign.
    // This tests whether one of them matches the test value.
    bool plusMinusAe(T, U)(T lhs, U rhs, string file = __FILE__, uint line = __LINE__) {
        // writefln(file ~ "(" ~ line.to!string ~ ",1): Debug: [%(%.12f, %)]", lhs);
        return isClose(lhs, rhs) || isClose(lhs, map!"-a"(rhs));
    }
}

unittest {
    // Values from R's prcomp function.  Not testing the 4th component because
    // it's mostly numerical fuzz.

    static double[][] getMat() {
        return [[3,6,2,4], [3,6,8,8], [6,7,5,3], [0,9,3,1]];
    }

    auto mat = getMat();
    auto allComps = firstNComponents(mat, 3);

    assert(plusMinusAe(allComps[0].x, [-1.190309611023, 5.106254623274, 0.536882440674, -4.452827452925]));
    assert(plusMinusAe(allComps[0].rotation, [0.314438614928, -0.269324957057, 0.583853827232, 0.698360317726]));

    assert(plusMinusAe(allComps[1].x, [0.804662072404, -1.779048956095, 2.882053262750, -1.907666379059]));
    assert(plusMinusAe(allComps[1].rotation, [0.911875506263, -0.180285805951, -0.249750506581, -0.271301997253]));

    assert(plusMinusAe(allComps[2].x, [-2.277209252383, 0.105586618978, 1.286672544033, 0.884950089372]));
    assert(plusMinusAe(allComps[2].rotation, [0.157856520582, 0.516206814724, 0.704400975064, -0.460902494755]));

    auto comp1 = firstComponent(mat);
    assert(plusMinusAe(comp1.x, allComps[0].x));
    assert(plusMinusAe(comp1.rotation, allComps[0].rotation));

    // Test transposed.
    PrinCompOptions opts;
    opts.transpose = true;
    const double[][] m2 = mat;
    auto allCompsT = firstNComponents(m2, 3, opts);

    assert(plusMinusAe(allCompsT[0].x, [-3.204536620708, 6.382966591576, -0.722708331235, -2.455721639633]));
    assert(plusMinusAe(allCompsT[0].rotation, [0.302547035085, 0.056578515705, 0.251419580455, 0.917634108828]));

    assert(plusMinusAe(allCompsT[1].x, [-3.461348962430, -0.636607889874, 1.751113616446, 2.346843235858]));
    assert(plusMinusAe(allCompsT[1].rotation, [-0.062691295444, 0.886437041789, -0.449813597484, 0.089257492334]));

    assert(plusMinusAe(allCompsT[2].x, [0.002899452720, 0.320106053329, -1.631347225534, 1.308341719486]));
    assert(plusMinusAe(allCompsT[2].rotation, [0.871406855522, -0.146282647210, -0.440971566070, -0.157466050918]));

    auto comp1T = firstComponent(m2, opts);
    assert(plusMinusAe(comp1T.x, allCompsT[0].x));
    assert(plusMinusAe(comp1T.rotation, allCompsT[0].rotation));

    // Test with scaling.
    opts.unitVariance = true;
    opts.transpose = false;
    auto allCompsScale = firstNComponents(mat, 3, opts);
    assert(plusMinusAe(allCompsScale[0].x, [-0.068803007437, 1.791673359217, 0.373357867453, -2.096228219233]));
    assert(plusMinusAe(allCompsScale[0].rotation, [0.390340396532, -0.539817964099, 0.476777033430, 0.573510767872]));

    assert(plusMinusAe(allCompsScale[1].x, [-0.680544174533, 0.941198462441, -0.923100543158, 0.662446255251]));
    assert(plusMinusAe(allCompsScale[1].rotation, [-0.735546484532, 0.285040822743, 0.506915236814, 0.347505454849]));

    assert(plusMinusAe(allCompsScale[2].x, [-0.961760321252, -0.014348321351, 0.812150350077, 0.163958292526]));
    assert(plusMinusAe(allCompsScale[2].rotation, [0.492550245080, 0.572143596491, 0.589678389531, -0.286923958543]));

    auto comp1S = firstComponent(m2, opts);
    assert(plusMinusAe(comp1S.x, allCompsScale[0].x));
    assert(plusMinusAe(comp1S.rotation, allCompsScale[0].rotation));

    opts.transpose = true;
    auto allTScale = firstNComponents(mat, 3, opts);

    assert(plusMinusAe(allTScale[0].x, [-0.141980754245, 2.141922423876, -0.836851832291, -1.163089837340]));
    assert(plusMinusAe(allTScale[0].rotation, [0.536179857406, -0.227058599807, 0.568566270739, 0.581109239769]));

    assert(plusMinusAe(allTScale[1].x, [-1.692899381798, 0.492909423755, 0.304950898787, 0.895039059256]));
    assert(plusMinusAe(allTScale[1].rotation, [0.302620610574, 0.790673309226, -0.365259260470, 0.387094506258]));

    assert(plusMinusAe(allTScale[2].x, [-0.203564434570, -0.027061601076, 0.911299154000, -0.680673118355]));
    assert(plusMinusAe(allTScale[2].rotation, [-0.733322756574, 0.339605225915, 0.483712568304, 0.336047878267]));

    auto comp1ST = firstComponent(m2, opts);
    assert(plusMinusAe(comp1ST.x, allTScale[0].x));
    assert(plusMinusAe(comp1ST.rotation, allTScale[0].rotation));

    void compAll(PrincipalComponent[] lhs, PrincipalComponent[] rhs) {
        assert(lhs.length == rhs.length);
        foreach(i, elem; lhs) {
            assert(plusMinusAe(elem.x, rhs[i].x));
            assert(plusMinusAe(elem.rotation, rhs[i].rotation));
        }
    }

    opts.destructive = true;
    auto allDestructive = firstNComponents(mat, 3, opts);
    compAll(allTScale, allDestructive);
    compAll([firstComponent(getMat(), opts)], allDestructive[0..1]);

    mat = getMat();
    opts.transpose = false;
    allDestructive = firstNComponents(mat, 3, opts);
    compAll(allDestructive, allCompsScale);
    compAll([firstComponent(getMat(), opts)], allDestructive[0..1]);

    mat = getMat();
    opts.unitVariance = false;
    allDestructive = firstNComponents(mat, 3, opts);
    compAll(allDestructive, allComps);
    compAll([firstComponent(getMat(), opts)], allDestructive[0..1]);

    mat = getMat();
    opts.transpose = true;
    allDestructive = firstNComponents(mat, 3, opts);
    compAll(allDestructive, allCompsT);
    compAll([firstComponent(getMat(), opts)], allDestructive[0..1]);
}
